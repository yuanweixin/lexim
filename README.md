# lexim
Lexer generation and regex implementation for Nim. A fork of https://github.com/Araq/lexim. Intended to be used in my toy compiler project. 


# details 

Lexim implements fsa based scanner, using the classic Regex -> NFA -> DFA -> minimization. Regex parsing uses recursive descent. The NFA -> DFA with subset construction, DFA minimization using Hopcroft's algorithm. The code generated is a computed goto that is embedded in the caller code, which is more efficient than simulating the DFA separately. 

No buffering scheme is given for the scanner. Since the toy compiler I write with this runs on modern desktops, memory is abundant and it is just added complexity to throw in buffering for a non-problem. No longer have to deal with multi-line tokens (if using a line-oriented buffer), or dealing with the possibility that a single token can exceed your buffer size. 

Lexim requires a 'lexe' helper exe that is used by 'lexim'.
Compile via ``nim c lexe`` and then you can run the example
via ``nim c ex1.nim``. It isn't strictly required, but does speed up the compilation process by offloading the expensive DFA construction to a separate process instead of doing it in the VM (for more complicated regex it generates the `interpretation requires too many iterations` error; fwiw it could be mitigated with compiler option `maxLoopIterationsVM:N` but that's ugly). 

# usage 

```
proc main =
  var input = "ithe 0909 else input elif elseo end"
  match input:
    string:
        r"\d+": echo "an integer ", input.substr(oldPos, pos-1), "##"
        "else": echo "an ELSE"
        "elif": echo "an ELIF"; beginState("initial")
        "end": echo "an END"
        r"[a-zA-Z_]\w+": echo "an identifier ", input.substr(oldPos, pos-1), "##"
        r".": echo "something else ", input.substr(oldPos, pos-1), "##"
    "i":
        echo "init state go to string"
        beginState(string)
    r".":
      echo "initial state dot match"
      discard
main()


Note, the loop to consume the input is generated by `match`. Support has been added for start conditions. In the above code we have the `string` and `initial` start conditions. The `initial` condition is always implicitly generated. 

Also note the presence of `r"."`, a catch-all rule to handle the case of nothing else matching. This is necessary. Without this, the code can be stuck in an endless loop. 

There's a hard coded `maxLabel` constant in `lexim/nfa.nim` which limits the total number of states. It can be raised as needed in the code. 

Names accessible by action code: 
* `pos` is accessible in action code, it points to the index after the last matched
* `oldPos` is the first position of match 
* `beginState` can be used to transition state. It can be a string or identifier. 

# note on longest match 
Textbook would say dfa should give the longest match. This lib does not actually try to greedily recognize the longest match. 

For example, say pattern is `a|aaa|b`, and we are given "aab". It would actually only recognize "b", reason being it reads 'a', reads another 'a', then sees the next char is not 'a', but does not backtrack its position, and so the next char ends up being 'b', which matches 'b'. 

This may look incorrect, but in practice in programming langauges, this likely doesn't affect correctness, as long as you do not have patterns that share a prefix that could trigger this behavior (e.g. pat="<<<|<|b" and given "<<b"). If we just do string recognition, it's easy to patch up the code (just track the last match position), But if we want to run arbitrary actions, then it would be a more involved change to implement that fallback. 

  